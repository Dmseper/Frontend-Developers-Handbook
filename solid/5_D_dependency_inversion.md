Принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей нижнего уровня.

И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей.

Детали должны зависеть от абстракций.

Предположим, у нас есть класс `Car`, который зависит от класса `Engine`. В данном примере, `Car` будет зависеть от конкретной реализации `Engine`, а не от абстракции.

```typescript
// Конкретная реализация (деталь) - класс Engine
class Engine {
  start(): void {
    console.log('Двигатель запущен');
  }
}

// Класс Car нарушает принцип инверсии зависимостей, так как зависит от конкретной реализации Engine
class Car {
  private engine: Engine;

  constructor() {
    this.engine = new Engine(); // Нарушение принципа инверсии зависимостей
  }

  startCar(): void {
    this.engine.start();
  }
}

// Использование
const car = new Car();
car.startCar();
```

В данном примере класс `Car` жестко связан с классом `Engine`, создавая его экземпляр в конструкторе, что нарушает принцип инверсии зависимостей. Это делает класс `Car` зависимым от конкретной реализации `Engine`, и если мы захотим заменить `Engine` на другую реализацию, нам придется изменять класс `Car`, что приведет к сложной и многочисленной зависимости.

Чтобы исправить нарушение принципа инверсии зависимостей, мы должны использовать абстракцию (интерфейс) для класса `Engine`, а затем передавать зависимость в `Car` через внешний источник, например, в конструктор:

```typescript
// Интерфейс абстракции (Engine)
interface Engine {
  start(): void;
}

// Конкретная реализация абстракции (CarEngine)
class CarEngine implements Engine {
  start(): void {
    console.log('Двигатель автомобиля запущен');
  }
}

// Класс Car использует абстракцию Engine, не зависит от конкретной реализации
class Car {
  private engine: Engine;

  constructor(engine: Engine) {
    this.engine = engine; // Использование абстракции Engine
  }

  startCar(): void {
    this.engine.start();
  }
}

// Использование
const carEngine = new CarEngine();
const car = new Car(carEngine);
car.startCar();
```

Теперь класс `Car` зависит от абстракции `Engine`, а не от конкретной реализации `CarEngine`. Это обеспечивает более слабую связность между классами и позволяет более легко заменять и расширять реализации двигателя без изменения кода класса `Car`.